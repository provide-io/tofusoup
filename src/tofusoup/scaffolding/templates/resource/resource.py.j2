"""
Scaffolded Pyvider Resource: {{ component_name }}
"""
from typing import Any
import attrs
from pyvider.hub import register_resource
from pyvider.resources.base import BaseResource
from pyvider.resources.context import ResourceContext
from pyvider.schema import PvsSchema, a_str, s_resource
from provide.foundation import logger

# Define an attrs class for this resource's configuration.
@attrs.define(frozen=True)
class {{ component_name | capitalize }}Config:
    example_attribute: str = attrs.field()

# Define an attrs class for this resource's state.
@attrs.define(frozen=True)
class {{ component_name | capitalize }}State:
    id: str = attrs.field()
    example_attribute: str = attrs.field()

@register_resource("{{ provider_name }}_{{ component_name | lower }}")
class {{ component_name | capitalize }}Resource(
    BaseResource[
        "{{ provider_name }}_{{ component_name | lower }}",
        {{ component_name | capitalize }}State,
        {{ component_name | capitalize }}Config
    ]
):
    """Manages the {{ component_name }} resource."""
    
    config_class = {{ component_name | capitalize }}Config
    state_class = {{ component_name | capitalize }}State

    @classmethod
    def get_schema(cls) -> PvsSchema:
        """Defines the schema for the {{ component_name }} resource."""
        return s_resource({
            "id": a_str(computed=True, description="Unique identifier for the resource."),
            "example_attribute": a_str(
                required=True, 
                description="An example configurable attribute."
            ),
        })

    async def read(self, ctx: ResourceContext) -> {{ component_name | capitalize }}State | None:
        """Reads the current state of the resource from the real world."""
        logger.info(f"Reading resource {ctx.state.id if ctx.state else 'new'}")

        # TODO: Implement your read logic here
        # Fetch the resource's actual state from your service/API
        # Return a State object if the resource exists, None if it doesn't
        #
        # Example:
        #   response = await your_api_client.get_resource(ctx.state.id)
        #   if response.found:
        #       return self.state_class(id=response.id, example_attribute=response.value)
        #   return None

        if ctx.state:
            return ctx.state
        return None

    async def plan(self, ctx: ResourceContext) -> tuple[{{ component_name | capitalize }}State | None, None]:
        """Calculates the planned state of the resource."""
        logger.info("Planning resource changes for {{ component_name }}")
        
        # If there is no prior state, we are creating a new resource.
        # We must predict the value of all computed attributes.
        resource_id = ctx.state.id if ctx.state else f"res-{{ component_name | lower }}-{id(ctx)}[:8]"
        
        planned_state = self.state_class(
            id=resource_id,
            example_attribute=ctx.config.example_attribute,
        )
        
        return planned_state, None

    async def apply(self, ctx: ResourceContext) -> tuple[{{ component_name | capitalize }}State | None, None]:
        """Creates or updates the resource to match the planned state."""
        logger.info("Applying resource changes for {{ component_name }}")

        # TODO: Implement your create/update logic here
        # Make API calls to create or update the resource
        # This method MUST be idempotent
        #
        # Example:
        #   if ctx.state is None:
        #       response = await your_api_client.create_resource(ctx.planned_state)
        #   else:
        #       response = await your_api_client.update_resource(ctx.state.id, ctx.planned_state)
        #
        # IMPORTANT: The returned state MUST match ctx.planned_state exactly
        return ctx.planned_state, None

    async def delete(self, ctx: ResourceContext) -> None:
        """Deletes the resource."""
        logger.info(f"Deleting resource {ctx.state.id if ctx.state else 'unknown'}")

        # TODO: Implement your delete logic here
        # Make API calls to delete the resource
        # This method MUST be idempotent (safe to call multiple times)
        #
        # Example:
        #   try:
        #       await your_api_client.delete_resource(ctx.state.id)
        #   except ResourceNotFoundError:
        #       logger.info(f"Resource {ctx.state.id} already deleted")
        #       pass  # Idempotent - already deleted is OK

        pass
