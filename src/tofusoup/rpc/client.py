#
# tofusoup/rpc/client.py
#
import asyncio
import logging
import os
import time

import grpc
from provide.foundation import logger

from tofusoup.config.defaults import (
    CONNECTION_TIMEOUT,
    ENV_GRPC_DEFAULT_CLIENT_CERTIFICATE_PATH,
    ENV_GRPC_DEFAULT_CLIENT_PRIVATE_KEY_PATH,
    ENV_GRPC_DEFAULT_SSL_ROOTS_FILE_PATH,
    REQUEST_TIMEOUT,
)
from tofusoup.rpc.validation import (
    detect_server_language,
    validate_curve_for_runtime,
    validate_language_pair,
)

# Optional RPC integration
try:
    from pyvider.rpcplugin.client import RPCPluginClient
    from pyvider.rpcplugin.config import rpcplugin_config

    HAS_RPC = True
except ImportError:
    HAS_RPC = False
    RPCPluginClient = None
    rpcplugin_config = {}
from tofusoup.harness.proto.kv import KVProtocol, kv_pb2, kv_pb2_grpc

logging.basicConfig(
    level=logging.WARNING,
    format="%(asctime)s.%(msecs)03d [%(levelname)-7s] %(name)s: 🐍 C> %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)


class KVClient:
    """Client for KV plugin server with mTLS and explicit config capabilities."""

    def __init__(
        self,
        server_path: str,
        tls_mode: str = "disabled",
        tls_key_type: str = "ec",
        tls_curve: str = "secp256r1",
        cert_file: str | None = None,
        key_file: str | None = None,
    ) -> None:
        self.tls_mode = tls_mode
        self.tls_key_type = tls_key_type
        self.tls_curve = tls_curve
        self.server_path = server_path
        self.cert_file = cert_file
        self.key_file = key_file

        # Validate language pair compatibility (Python client → server)
        try:
            validate_language_pair("python", server_path)
        except Exception as e:
            logger.warning("Language pair validation warning", error=str(e))
            # Don't fail in __init__, just warn

        # Validate curve support
        if tls_key_type == "ec" and tls_curve not in ["auto", ""]:
            try:
                validate_curve_for_runtime(tls_curve, "python")
            except Exception as e:
                logger.warning("Curve validation warning", error=str(e))
                # Don't fail in __init__, just warn
        self._client: RPCPluginClient | None = None
        self._stub: kv_pb2_grpc.KVStub | None = None
        self.is_started = False
        self.connection_timeout = CONNECTION_TIMEOUT

        # Map tls_mode to enable_mtls for internal use
        self.enable_mtls = self.tls_mode != "disabled"

        go_server_expected_cookie_key = "BASIC_PLUGIN"
        go_server_expected_cookie_value = "hello"
        go_server_protocol_version = "1"

        # Note: Don't set PLUGIN_AUTO_MTLS when using TLSProvider (specific curve)
        # AutoMTLS and TLSProvider are mutually exclusive in go-plugin
        use_auto_mtls = self.enable_mtls and (self.tls_curve == "auto" or not self.tls_curve)

        self.subprocess_env = {
            "PLUGIN_MAGIC_COOKIE_KEY": go_server_expected_cookie_key,
            go_server_expected_cookie_key: go_server_expected_cookie_value,
            "PLUGIN_PROTOCOL_VERSIONS": go_server_protocol_version,
            "LOG_LEVEL": os.getenv("LOG_LEVEL", logger.level.name if hasattr(logger, "level") else "INFO"),  # type: ignore
            "PYTHONUNBUFFERED": "1",
            "GODEBUG": os.getenv("GODEBUG", "asyncpreemptoff=1,panicasync=1"),
            "PLUGIN_AUTO_MTLS": "true" if use_auto_mtls else "false",
        }

        # Map TLS key type to legacy environment variables if needed
        if self.tls_key_type == "ec":
            self.subprocess_env["PYVIDER_CLIENT_CERT_ALGO"] = "ecdsa"
            self.subprocess_env["PYVIDER_CLIENT_CERT_CURVE"] = self.tls_curve
        elif self.tls_key_type == "rsa":
            self.subprocess_env["PYVIDER_CLIENT_CERT_ALGO"] = "rsa"

        # Magic cookie configuration is set via subprocess_env dict above
        # No need to modify rpcplugin_config directly as it reads from environment
        logger.info(f"[KVClient.__init__] self.subprocess_env for plugin: {self.subprocess_env}")

    def _build_tls_command_args(self) -> list[str]:
        """Build command-line arguments for TLS configuration.

        Returns:
            List of command-line arguments for server TLS setup.

        Raises:
            ValueError: If manual TLS mode is specified without required certificates.
        """
        args: list[str] = ["--tls-mode", self.tls_mode]

        if self.tls_mode == "auto":
            # Both Go and Python servers support --tls-key-type and --tls-curve flags
            args.extend(["--tls-key-type", self.tls_key_type])
            args.extend(["--tls-curve", self.tls_curve])
            logger.info(
                f"KVClient: Auto TLS enabled with key type: {self.tls_key_type}, curve: {self.tls_curve}"
            )
        elif self.tls_mode == "manual":
            if self.cert_file and self.key_file:
                args.extend(["--cert-file", self.cert_file])
                args.extend(["--key-file", self.key_file])
                logger.info(
                    f"KVClient: Manual TLS enabled with cert: {self.cert_file}, key: {self.key_file}"
                )
            else:
                # Fallback: try to get paths from environment variables
                server_cert_path = os.getenv("PLUGIN_SERVER_CERT")
                server_key_path = os.getenv("PLUGIN_SERVER_KEY")
                if server_cert_path and server_key_path:
                    args.extend(["--cert-file", server_cert_path])
                    args.extend(["--key-file", server_key_path])
                    logger.info(
                        f"KVClient: Manual TLS enabled using env vars - cert: {server_cert_path}, key: {server_key_path}"
                    )
                else:
                    logger.error("KVClient: Manual TLS mode requires cert-file and key-file")
                    raise ValueError(
                        "Manual TLS mode requires cert_file and key_file parameters or PLUGIN_SERVER_CERT/PLUGIN_SERVER_KEY environment variables"
                    )
        else:  # disabled
            logger.info("KVClient: TLS disabled - running in insecure mode")

        return args

    def _build_server_command(self) -> list[str]:
        """Build the complete server command with TLS arguments.

        Returns:
            Complete command list to start the server.

        Raises:
            FileNotFoundError: If server executable doesn't exist.
            PermissionError: If server executable is not executable.
        """
        # Validate server path
        if not os.path.exists(self.server_path):
            raise FileNotFoundError(f"Server executable not found: {self.server_path}")
        if not os.access(self.server_path, os.X_OK):
            raise PermissionError(f"Server executable not executable: {self.server_path}")

        server_command = [self.server_path]

        # Check if binary name suggests it needs subcommands
        binary_name = os.path.basename(self.server_path)
        if binary_name in ["soup-go", "go-harness", "soup"]:
            # New harnesses (both Go and Python) expect rpc server-start subcommand
            server_command.extend(["rpc", "server-start"])

        # Add TLS configuration arguments
        server_command.extend(self._build_tls_command_args())

        logger.info(f"Effective server command for plugin: {' '.join(server_command)}")
        return server_command

    def _prepare_environment(self) -> dict[str, str]:
        """Prepare the environment variables for the server subprocess.

        Returns:
            Dictionary of environment variables for server subprocess.
        """
        # Start with current env (includes what tests might have monkeypatched)
        effective_env = os.environ.copy()

        # Merge KVClient's base env for plugin (e.g., GODEBUG, PYTHONUNBUFFERED)
        effective_env.update(self.subprocess_env)

        # Set up magic cookies in the server's effective_env
        go_server_expected_cookie_key_name = "BASIC_PLUGIN"
        go_server_expected_cookie_value = "hello"
        effective_env["PLUGIN_MAGIC_COOKIE_KEY"] = go_server_expected_cookie_key_name
        effective_env[go_server_expected_cookie_key_name] = go_server_expected_cookie_value

        # Clean up any conflicting cookie keys
        if (
            "PLUGIN_MAGIC_COOKIE" in effective_env
            and go_server_expected_cookie_key_name != "PLUGIN_MAGIC_COOKIE"
        ):
            del effective_env["PLUGIN_MAGIC_COOKIE"]

        logger.info(
            f"Final effective_env for subprocess will include: PLUGIN_MAGIC_COOKIE_KEY={effective_env.get('PLUGIN_MAGIC_COOKIE_KEY')}, {go_server_expected_cookie_key_name}={effective_env.get(go_server_expected_cookie_key_name)}"
        )

        return effective_env

    def _build_client_config(self, env: dict[str, str]) -> dict:
        """Build the configuration dictionary for RPCPluginClient.

        Args:
            env: Environment variables for the server subprocess.

        Returns:
            Configuration dictionary for RPCPluginClient constructor.
        """
        client_config = {
            "plugins": {"kv": KVProtocol()},
            "env": env,  # Env for the server subprocess it launches
            "enable_mtls": self.enable_mtls,
        }

        if self.enable_mtls:
            # Tests use GRPC_DEFAULT_* env vars for client's mTLS materials
            client_cert_path_env = os.getenv(ENV_GRPC_DEFAULT_CLIENT_CERTIFICATE_PATH)
            client_key_path_env = os.getenv(ENV_GRPC_DEFAULT_CLIENT_PRIVATE_KEY_PATH)
            server_ca_path_env = os.getenv(ENV_GRPC_DEFAULT_SSL_ROOTS_FILE_PATH)

            if client_cert_path_env and client_key_path_env and server_ca_path_env:
                logger.info(
                    "KVClient: Populating RPCPluginClient config for mTLS with paths from GRPC_DEFAULT_* env vars."
                )
                client_config["client_cert_path"] = client_cert_path_env
                client_config["client_key_path"] = client_key_path_env
                client_config["server_root_ca_path"] = server_ca_path_env
            else:
                logger.warning(
                    f"KVClient: mTLS enabled for KVClient, but not all {ENV_GRPC_DEFAULT_CLIENT_CERTIFICATE_PATH}, "
                    f"{ENV_GRPC_DEFAULT_CLIENT_PRIVATE_KEY_PATH}, or {ENV_GRPC_DEFAULT_SSL_ROOTS_FILE_PATH} env vars are set. "
                    "RPCPluginClient might not establish mTLS correctly if it relies on these config paths."
                )

        logger.debug(f"KVClient: Final client_constructor_config for RPCPluginClient: {client_config}")
        return client_config

    async def start(self) -> None:
        """Start the KV server and establish connection.

        Raises:
            FileNotFoundError: If server executable doesn't exist.
            PermissionError: If server executable is not executable.
            ValueError: If TLS configuration is invalid.
            ConnectionError: If connection fails or times out.
            TimeoutError: If connection attempt exceeds timeout.
        """
        start_time = time.time()
        self.is_started = False
        try:
            logger.debug(f"KVClient attempting to start server: {self.server_path}")

            # Build server command (validates path and adds TLS args)
            server_command = self._build_server_command()

            # Prepare environment variables for server subprocess
            effective_env = self._prepare_environment()

            # Configure RPCPluginClient (Python gRPC client)
            client_config = self._build_client_config(effective_env)

            # Create and start client
            self._client = RPCPluginClient(
                command=server_command,
                config=client_config,
            )

            logger.debug(f"Starting RPCPluginClient (pyvider), timeout={self.connection_timeout}s")
            await asyncio.wait_for(self._client.start(), timeout=self.connection_timeout)

            # Relay stderr if available
            if (
                self._client._process
                and hasattr(self._client._process, "stderr")
                and self._client._process.stderr
            ):
                self._relay_stderr()

            # Create gRPC stub and mark as started
            self._stub = kv_pb2_grpc.KVStub(self._client.grpc_channel)
            self.is_started = True

            # Log successful connection
            pid = getattr(self._client._process, "pid", "N/A") if self._client._process else "N/A"
            logger.info(f"KVClient connected to server in {time.time() - start_time:.3f}s. Server PID: {pid}")

        except TimeoutError as e:
            elapsed = time.time() - start_time
            logger.error(f"KVClient connection to server timed out after {elapsed:.3f}s")
            # Safely check if process is still running (ManagedProcess may not have poll())
            if self._client and self._client._process:
                poll_result = getattr(self._client._process, "poll", lambda: None)()
                if poll_result is None or (
                    hasattr(self._client._process, "returncode") and self._client._process.returncode is None
                ):
                    logger.debug("Server process was still running after client timeout.")
            self.is_started = False

            # Check if this is a Python → Go connection (known incompatibility)
            server_lang = detect_server_language(self.server_path)
            if server_lang == "go":
                raise ConnectionError(
                    f"Connection timeout after {elapsed:.3f}s - Python client → Go server is not supported.\n\n"
                    "This is a known issue in pyvider-rpcplugin.\n\n"
                    "Supported alternatives:\n"
                    "  ✓ Go client → Python server (use soup-go binary as client)\n"
                    "  ✓ Python client → Python server\n"
                    "  ✓ Go client → Go server\n\n"
                    f"Server path: {self.server_path}"
                ) from e
            raise
        except Exception as e:
            elapsed = time.time() - start_time
            logger.error(
                f"KVClient failed to connect/start server: {type(e).__name__} - {e}",
                exc_info=True,
            )
            self.is_started = False

            # Provide additional context for common errors
            server_lang = detect_server_language(self.server_path)
            error_msg = str(e)

            # Check for language pair issues
            if server_lang == "go" and ("connection" in error_msg.lower() or "handshake" in error_msg.lower()):
                raise ConnectionError(
                    f"Failed to connect to Go server - Python client → Go server is not supported.\n\n"
                    "This is a known issue in pyvider-rpcplugin.\n\n"
                    "Supported alternatives:\n"
                    "  ✓ Go client → Python server\n"
                    "  ✓ Python client → Python server\n"
                    "  ✓ Go client → Go server\n\n"
                    f"Original error: {type(e).__name__}: {e}"
                ) from e

            # Check for curve compatibility issues
            if "curve" in error_msg.lower() or "tls" in error_msg.lower() or "ssl" in error_msg.lower():
                if self.tls_curve == "secp521r1" and server_lang == "python":
                    raise ValueError(
                        f"Curve 'secp521r1' is not supported by Python's grpcio library.\n"
                        "Supported curves for Python: secp256r1, secp384r1\n\n"
                        f"Original error: {type(e).__name__}: {e}"
                    ) from e

            raise

    def _relay_stderr(self) -> None:
        import threading

        if not (self._client and self._client._process and self._client._process.stderr):
            logger.warning("stderr relay: client process or stderr not available.")
            return
        stderr_pipe = self._client._process.stderr

        def read_stderr_thread() -> None:
            logger.debug("stderr relay thread started.")
            while True:
                try:
                    if stderr_pipe.closed:
                        break
                    if not self._client or not self._client._process:
                        break
                    line_bytes = stderr_pipe.readline()
                    if not line_bytes:
                        break
                    decoded = line_bytes.decode("utf-8", errors="replace").strip()
                    if decoded:
                        logger.debug(f"SERVER_STDERR: {decoded}")
                except ValueError:
                    break
                except Exception as e:
                    logger.error(
                        f"Error in stderr relay thread: {type(e).__name__} - {e}",
                        exc_info=True,
                    )
                    break
            logger.debug("stderr relay thread finished.")

        thread = threading.Thread(target=read_stderr_thread, daemon=True)
        thread.start()

    async def close(self) -> None:
        if self._client:
            logger.debug("KVClient closing connection...")
            self.is_started = False
            try:
                # Safely check if process is still running (ManagedProcess may not expose returncode directly)
                process_running = False
                if self._client._process:
                    returncode = getattr(self._client._process, "returncode", None)
                    process_running = returncode is None

                if process_running:
                    if hasattr(self._client, "close") and asyncio.iscoroutinefunction(self._client.close):
                        await self._client.close()
                    elif hasattr(self._client, "close"):
                        self._client.close()
                    logger.debug("RPCPluginClient close called.")
                else:
                    logger.debug("RPCPluginClient process already terminated or not started.")
            except Exception as e:
                logger.error(
                    f"Error during RPCPluginClient.close(): {type(e).__name__} - {e}",
                    exc_info=True,
                )
            finally:
                self._client = None
                self._stub = None
                logger.debug("KVClient connection closed and attributes reset.")
        else:
            self.is_started = False
            logger.debug("KVClient.close() called but client was not initialized or already closed.")

    async def put(self, key: str, value: bytes) -> None:
        if not self.is_started or not self._stub:
            raise RuntimeError("KVClient not connected to server.")
        if not isinstance(value, bytes):
            raise TypeError("Value for put must be bytes.")
        try:
            logger.debug(f"KVClient: Sending Put - key='{key}', value_size={len(value)} bytes.")
            await asyncio.wait_for(
                self._stub.Put(kv_pb2.PutRequest(key=key, value=value)), timeout=REQUEST_TIMEOUT
            )
            logger.info(f"KVClient: Put successful for key='{key}'.")
        except TimeoutError:
            logger.error(f"KVClient: Put operation timed out for key='{key}'.")
            raise
        except Exception as e:
            logger.error(
                f"KVClient: Put failed for key='{key}'. Error: {type(e).__name__} - {e}",
                exc_info=True,
            )
            raise

    async def get(self, key: str) -> bytes | None:
        if not self.is_started or not self._stub:
            raise RuntimeError("KVClient not connected to server.")
        try:
            logger.debug(f"KVClient: Sending Get - key='{key}'.")
            response = await asyncio.wait_for(
                self._stub.Get(kv_pb2.GetRequest(key=key)), timeout=REQUEST_TIMEOUT
            )

            if response is not None:
                # In proto3, a bytes field defaults to empty bytes if not explicitly set.
                # The server's Get RPC implementation for a non-existent key returns a gRPC NOT_FOUND error,
                # which is caught by the AioRpcError handler below.
                # So, if we get here with a non-None response, the key was found.
                # response.value will be the bytes (could be empty if an empty value was stored).
                logger.info(
                    f"KVClient: Get successful for key='{key}', retrieved {len(response.value)} bytes."
                )
                return response.value
            else:
                # This path should ideally not be reached given gRPC behavior (either response or error).
                logger.warning(f"KVClient: Get for key='{key}' returned a None response object (unexpected).")
                return None
        except grpc.aio.AioRpcError as e:
            if e.code() == grpc.StatusCode.NOT_FOUND:
                logger.info(f"KVClient: Key='{key}' not found on server (gRPC StatusCode.NOT_FOUND).")
                return None  # Correctly return None for not found
            logger.error(
                f"KVClient: Get for key='{key}' failed with gRPC error {e.code()}: {e.details()}",
                exc_info=True,
            )
            raise
        except TimeoutError:  # Keep specific timeout error handling
            logger.error(f"KVClient: Get operation timed out for key='{key}'.")
            raise
        except Exception as e:
            logger.error(
                f"KVClient: Get for key='{key}' failed. Error: {type(e).__name__} - {e}",
                exc_info=True,
            )
            raise


# 🍲🥄🖥️🪄
