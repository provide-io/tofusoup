#
# SPDX-FileCopyrightText: Copyright (c) 2025 provide.io llc. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#

"""Generates canonical MessagePack fixtures and a JSON manifest from pyvider.cty.
This script is the "source of truth" for the reverse compatibility test."""

import argparse
from decimal import Decimal
import json
from pathlib import Path
from typing import Any

import attrs

from pyvider.cty import (
    CtyBool,
    CtyDynamic,
    CtyList,
    CtyMap,
    CtyNumber,
    CtyObject,
    CtySet,
    CtyString,
    CtyTuple,
    CtyValue,
)
from pyvider.cty.codec import cty_to_msgpack
from pyvider.cty.conversion import encode_cty_type_to_wire_json
from pyvider.cty.values.markers import RefinedUnknownValue

_UNKNOWN_SENTINEL = {"$pyvider-cty-special-value": "unknown"}


def get_test_cases() -> dict[str, CtyValue]:
    """Defines all canonical test cases to be generated by Python."""
    CtyTuple(element_types=(CtyString(), CtyNumber()))

    return {
        "string_simple": CtyString().validate("hello from python"),
        "number_simple": CtyNumber().validate(12345),
        "bool_true": CtyBool().validate(True),
        "large_number": CtyNumber().validate(Decimal(2**128)),
        "null_string": CtyValue.null(CtyString()),
        "unknown_unrefined": CtyValue.unknown(CtyNumber()),
        "unknown_refined_str": CtyValue.unknown(CtyString(), value=RefinedUnknownValue(string_prefix="py-")),
        "unknown_refined_list": CtyValue.unknown(
            CtyList(element_type=CtyString()),
            value=RefinedUnknownValue(collection_length_lower_bound=1, collection_length_upper_bound=5),
        ),
        "list_of_strings": CtyList(element_type=CtyString()).validate(["py-a", "py-b"]),
        "set_of_numbers": CtySet(element_type=CtyNumber()).validate({100, 200, 300}),
        "map_simple": CtyMap(element_type=CtyBool()).validate({"py_a": True, "py_b": False}),
        "deeply_nested_object": CtyObject(
            {
                "id": CtyString(),
                "enabled": CtyBool(),
                "ports": CtyList(element_type=CtyNumber()),
                "config": CtyObject({"retries": CtyNumber(), "params": CtyMap(element_type=CtyString())}),
                "metadata": CtyMap(element_type=CtyString()),
                "extra": CtyString(),
            },
            optional_attributes={"metadata"},
        ).validate(
            {
                "id": "py-obj1",
                "enabled": True,
                "ports": [8080, 8443],
                "config": {"retries": 3, "params": {"timeout": "10s"}},
                "metadata": None,
                "extra": CtyValue.unknown(CtyString()),
            }
        ),
        "dynamic_wrapped_string": CtyDynamic().validate("dynamic from python"),
        "dynamic_wrapped_object": CtyDynamic().validate(
            CtyObject({"key": CtyString()}).validate({"key": "py-value"})
        ),
    }


def _format_refined_unknown(refined_value: RefinedUnknownValue) -> Any:
    """Format refined unknown value with proper Decimal handling."""
    refinements = {k: v for k, v in attrs.asdict(refined_value).items() if v is not None}
    if not refinements:
        return _UNKNOWN_SENTINEL

    formatted_refinements = {}
    for k, v in refinements.items():
        if isinstance(v, tuple) and isinstance(v[0], Decimal):
            formatted_refinements[k] = (str(v[0]), v[1])
        else:
            formatted_refinements[k] = v

    return {
        "$pyvider-cty-special-value": "unknown",
        "refinements": formatted_refinements,
    }


def _convert_value_type(val: Any) -> Any:
    """Convert a value based on its type."""
    if isinstance(val, Decimal):
        return str(val)
    if isinstance(val, tuple):
        return [cty_to_manifest_native(item) for item in val]
    if isinstance(val, frozenset):
        sorted_cty_items = sorted(val, key=lambda v: v._canonical_sort_key())
        return [cty_to_manifest_native(item) for item in sorted_cty_items]
    if isinstance(val, dict):
        return {k: cty_to_manifest_native(v) for k, v in sorted(val.items())}
    return val


def cty_to_manifest_native(value: CtyValue) -> Any:
    """Converts a CtyValue to a native Python type suitable for the JSON manifest."""
    if value.is_unknown:
        if isinstance(value.value, RefinedUnknownValue):
            return _format_refined_unknown(value.value)
        return _UNKNOWN_SENTINEL
    if value.is_null:
        return None
    if isinstance(value.type, CtyDynamic):
        return cty_to_manifest_native(value.value)

    return _convert_value_type(value.value)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate pyvider.cty test fixtures.")
    parser.add_argument(
        "-d", "--directory", required=True, type=Path, help="Directory to write fixtures and manifest."
    )
    args = parser.parse_args()

    output_dir: Path = args.directory
    output_dir.mkdir(parents=True, exist_ok=True)

    test_cases = get_test_cases()
    manifest = {}

    for name, value in test_cases.items():
        schema_for_packing = CtyDynamic() if isinstance(value.type, CtyDynamic) else value.type
        msgpack_bytes = cty_to_msgpack(value, schema_for_packing)
        (output_dir / f"{name}.msgpack").write_bytes(msgpack_bytes)

        manifest_type = CtyDynamic() if isinstance(value.type, CtyDynamic) else value.type

        manifest[name] = {
            "type": encode_cty_type_to_wire_json(manifest_type),
            "value": cty_to_manifest_native(value),
            "isUnknown": value.is_unknown,
            "isNull": value.is_null,
        }

    (output_dir / "manifest.json").write_text(json.dumps(manifest, indent=2))


if __name__ == "__main__":
    main()

# ðŸ¥£ðŸ”¬ðŸ”š
