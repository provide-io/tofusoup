import pytest
import subprocess
import sys
import os
import json
import msgpack
from pathlib import Path
from decimal import Decimal
from typing import Any

from pyvider.cty import (
    CtyBool, CtyDynamic, CtyList, CtyMap, CtyNumber, CtyObject, CtySet,
    CtyString, CtyTuple, CtyValue
)
from pyvider.cty.codec import cty_from_msgpack, cty_to_msgpack, _convert_value_to_serializable
from pyvider.cty.conversion import encode_cty_type_to_wire_json
from pyvider.cty.values.markers import UnknownValue, RefinedUnknownValue

from ..cli_verification.shared_cli_utils import run_harness_cli

def _cty_value_to_json_compatible_value(cty_value: CtyValue) -> Any:
    """
    Converts a CtyValue to a Python object that is directly JSON serializable.
    Handles special cases like UnknownValue and CtyDynamic.
    """
    if cty_value.is_null:
        return None
    if cty_value.is_unknown:
        # For unknown values, we need to represent their internal structure.
        # The _serialize_unknown function returns msgpack.ExtType, which is not JSON serializable.
        # We need to convert it to a dict/string representation.
        if isinstance(cty_value.value, RefinedUnknownValue):
            # Convert RefinedUnknownValue to a dict for JSON serialization
            return {
                "is_known_null": cty_value.value.is_known_null,
                "string_prefix": cty_value.value.string_prefix,
                "number_lower_bound": str(cty_value.value.number_lower_bound[0]) if cty_value.value.number_lower_bound else None,
                "number_upper_bound": str(cty_value.value.number_upper_bound[0]) if cty_value.value.number_upper_bound else None,
                "collection_length_lower_bound": cty_value.value.collection_length_lower_bound,
                "collection_length_upper_bound": cty_value.value.collection_length_upper_bound,
            }
        return "<UNKNOWN>" # Simple representation for unrefined unknown

    if isinstance(cty_value.type, CtyDynamic):
        # For CtyDynamic, its value is another CtyValue. Recursively convert it.
        return _cty_value_to_json_compatible_value(cty_value.value)

    # For other types, _convert_value_to_serializable should return a JSON-compatible type
    serializable_data = _convert_value_to_serializable(cty_value, cty_value.type)
    
    # Handle Decimal conversion to string for JSON compatibility
    if isinstance(serializable_data, Decimal):
        return str(serializable_data)
    
    # Recursively handle lists and dicts to ensure all nested Decimals are converted
    if isinstance(serializable_data, dict):
        return {k: _cty_value_to_json_compatible_value(v) if isinstance(v, CtyValue) else v for k, v in serializable_data.items()}
    if isinstance(serializable_data, list):
        return [_cty_value_to_json_compatible_value(item) if isinstance(item, CtyValue) else item for item in serializable_data]

    return serializable_data

# This dictionary now serves a dual purpose:
# 1. The *source* for generating Python fixtures to be validated by Go.
# 2. The *expected values* to compare against when Go generates fixtures.
GO_TEST_CASES: dict[str, CtyValue] = {
    "string_simple": CtyString().validate("hello world"),
    "number_simple": CtyNumber().validate(42),
    "bool_true": CtyBool().validate(True),
    "large_number": CtyNumber().validate(Decimal(2**100)),
    "null_string": CtyValue.null(CtyString()),
    "unknown_unrefined": CtyValue.unknown(CtyString()),
    "list_of_strings": CtyList(element_type=CtyString()).validate(["a", "b"]),
    "set_of_numbers": CtySet(element_type=CtyNumber()).validate({1, 2}),
    "map_simple": CtyMap(element_type=CtyBool()).validate({"a": True, "b": False}),
    "dynamic_wrapped_string": CtyDynamic().validate("dynamic"),
}

@pytest.mark.integration_cty
@pytest.mark.harness_go
@pytest.mark.parametrize("go_harness_executable", ["soup-go"], indirect=True)
@pytest.mark.parametrize("case_name", GO_TEST_CASES.keys())
def test_python_deserializes_go_fixtures(
    go_harness_executable: Path,
    project_root: Path,
    tmp_path: Path,
    case_name: str,
):
    """
    Tests Python's ability to deserialize MessagePack fixtures generated by the Go harness.
    (Go -> Python Interoperability)
    """
    # 1. Use soup-go cty convert to generate a fixture
    go_fixture_dir = tmp_path / "go_fixtures"
    go_fixture_dir.mkdir()
    output_file = go_fixture_dir / f"{case_name}.msgpack"
    
    # The input to the 'convert' command is a JSON representation of the CtyValue
    cty_value = GO_TEST_CASES[case_name]
    input_json = json.dumps(_cty_value_to_json_compatible_value(cty_value))
    type_json_for_go = json.dumps(encode_cty_type_to_wire_json(cty_value.type))

    exit_code, _, stderr = run_harness_cli(
        executable=go_harness_executable,
        args=["cty", "convert", "-", str(output_file), "--input-format", "json", "--output-format", "msgpack", "--type", type_json_for_go],
        project_root=project_root,
        harness_artifact_name="soup-go",
        test_id=f"generate_fixture_{case_name}",
        stdin_input=input_json
    )
    assert exit_code == 0, f"soup-go cty convert failed: {stderr}"

    # 2. Read the generated fixture
    assert output_file.exists(), f"Go harness did not generate fixture for {case_name}"
    msgpack_bytes = output_file.read_bytes()

    # 3. Deserialize using Python's logic
    deserialized_value = cty_from_msgpack(msgpack_bytes, cty_value.type)

    # 4. Assert equality
    assert deserialized_value == cty_value, (
        f"Mismatch for case '{case_name}'.\n"
        f"Expected: {cty_value!r}\n"
        f"Got:      {deserialized_value!r}"
    )

@pytest.mark.integration_cty
@pytest.mark.harness_go
@pytest.mark.parametrize("go_harness_executable", ["soup-go"], indirect=True)
def test_go_verifies_python_fixtures(
    go_harness_executable: Path,
    project_root: Path,
    tmp_path: Path,
):
    """
    Tests Go's ability to verify MessagePack fixtures generated by Python.
    (Python -> Go Interoperability)
    """
    py_fixture_dir = tmp_path / "py_fixtures"
    py_fixture_dir.mkdir()

    # 1. Generate Python fixtures
    for case_name, cty_value in GO_TEST_CASES.items():
        fixture_file = py_fixture_dir / f"{case_name}.msgpack"
        fixture_file.write_bytes(cty_to_msgpack(cty_value, cty_value.type))

    # 2. Verify each fixture using soup-go cty validate-value
    for case_name, cty_value in GO_TEST_CASES.items():
        fixture_file = py_fixture_dir / f"{case_name}.msgpack"
        
        # We need the CTY type string for the --type flag
        type_json_for_go = json.dumps(encode_cty_type_to_wire_json(cty_value.type))
        
        # The value for validate-value is a JSON string
        value_json = json.dumps(_cty_value_to_json_compatible_value(cty_value))

        exit_code, _, stderr = run_harness_cli(
            executable=go_harness_executable,
            args=["cty", "validate-value", value_json, "--type", type_json_for_go],
            project_root=project_root,
            harness_artifact_name="soup-go",
            test_id=f"verify_fixture_{case_name}"
        )
        assert exit_code == 0, f"soup-go cty validate-value failed for {case_name}: {stderr}"

# üç≤ü•Ñüß™ü™Ñ
